# 연결 리스트(Linked List)란?

```js
{ val: 10, next: → }
              ↓
      { val: 20, next: → }
                      ↓
              { val: 30, next: → null }
```

각 노드(Node)는 두 가지 정보만 가지고 있다:

- val: 값
- next: 다음 노드를 가리키는 포인터 (or 참조)

값은 흩어져 있지만, next를 통해 하나씩 연결돼 있는 것! 그래서 연결 리스트라고 부른다.

예: 자바스크립트 객체로 연결 리스트 만들기

```js
let node3 = { val: 30, next: null };
let node2 = { val: 20, next: node3 };
let node1 = { val: 10, next: node2 };

let head = node1; // head는 연결 리스트의 시작점
```

결과적으로 이런 구조:

```yaml
head → { val: 10, next: → }
                      ↓
          { val: 20, next: → }
                          ↓
                  { val: 30, next: null }
```

# 배열과 비교

| 배열(Array)                                    | 연결 리스트(Linked List)                    |
| ---------------------------------------------- | ------------------------------------------- |
| 삽입/삭제가 느림 (`splice`, `push`, `unshift`) | 빠름 (노드 하나만 바꾸면 됨)                |
| 인덱스로 바로 접근 가능 (`arr[3]`)             | 순차 접근만 가능 (`head → next → next`)     |
| 메모리에 연속적으로 있음                       | 여기저기 흩어져 있어도 됨 (`next`로 연결됨) |

### 배열과 비교하는 이유

1. **둘 다 "데이터를 나열하는 자료구조"이기 때문**
   배열(Array)와 연결 리스트(Linked List)는 같은 목적을 가지고 있다
   → 데이터를 순서대로 저장하고, 하나씩 꺼내거나 수정하기 위함
   그래서 **"같은 목적을 다른 방식으로 구현한 자료구조"**라서 비교가 되는 것.

| 예시: 하고 싶은 일 | 배열        | 연결 리스트 |
| ------------------ | ----------- | ----------- |
| 1번, 2번, 3번 저장 | `[1, 2, 3]` | `1 → 2 → 3` |

2. **같은 문제를 푸는 방식이 달라짐**

그래서 알고리즘에 미치는 영향이 커진다!

- 배열은 → 인덱스로 바로 접근
- 연결 리스트는 → next를 따라가면서 접근

배열 기반 풀이는 O(1) 접근이 쉬움
연결 리스트 기반 풀이는 O(n) 걸릴 수 있음

→ 그러니까 문제를 푸는 방식 자체가 달라져서 자료구조 선택이 중요해짐!

3. **연결 리스트 문제는 대부분 "배열로는 어려운 것"을 해결하려고 함**

예를 들어:

- 노드 삽입/삭제를 자주 해야 하는 문제
- 메모리를 연속적으로 쓰지 못하는 상황
- 구조가 동적으로 바뀌는 경우

이럴 땐 연결 리스트가 더 효율적이다.

### ✅ 결론

배열과 연결 리스트는 **동일한 목적(순서 있는 데이터 저장)**을 가진 자료구조이지만,
내부 구조와 성능 특성이 완전히 달라서,
문제 해결에 있어 서로의 장단점을 비교하며 선택해야 한다.
